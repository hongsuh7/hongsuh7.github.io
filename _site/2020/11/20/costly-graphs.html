<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Costly Graphs Solution | In All Probably</title>
<meta name="generator" content="Jekyll v3.8.7" />
<meta property="og:title" content="Costly Graphs Solution" />
<meta name="author" content="Hong Suh" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I came across a HackerRank problem that seemed quite mathematically involved, though it was labeled a medium. The title of the problem is Costly Graphs." />
<meta property="og:description" content="I came across a HackerRank problem that seemed quite mathematically involved, though it was labeled a medium. The title of the problem is Costly Graphs." />
<link rel="canonical" href="http://localhost:4000/2020/11/20/costly-graphs.html" />
<meta property="og:url" content="http://localhost:4000/2020/11/20/costly-graphs.html" />
<meta property="og:site_name" content="In All Probably" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-11-20T14:24:56-08:00" />
<script type="application/ld+json">
{"headline":"Costly Graphs Solution","dateModified":"2020-11-20T14:24:56-08:00","datePublished":"2020-11-20T14:24:56-08:00","url":"http://localhost:4000/2020/11/20/costly-graphs.html","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2020/11/20/costly-graphs.html"},"author":{"@type":"Person","name":"Hong Suh"},"description":"I came across a HackerRank problem that seemed quite mathematically involved, though it was labeled a medium. The title of the problem is Costly Graphs.","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="In All Probably" /><!-- Enables MathJax 
<script type="text/x-mathjax-config"> MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: "all" } } }); </script>
<script type="text/x-mathjax-config">
MathJax.Hub.Register.StartupHook('TeX Jax Ready', function () {
  MathJax.InputJax.TeX.prefilterHooks.Add(function (data) {
    data.math = data.math.replace(/^% <!\[CDATA\[/, '').replace(/%\]\]>$/, '');
  });
});
</script>-->
<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$']],
    displayMath: [["++","++"]]
  },
  svg: {
    fontCache: 'global'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script></head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">In All Probably</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about.html">About</a><a class="page-link" href="/">Portfolio</a><a class="page-link" href="/posts.html">Posts</a><a class="page-link" href="/resume.html">Resume</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Costly Graphs Solution</h1>
    <p class="post-meta"><time class="dt-published" datetime="2020-11-20T14:24:56-08:00" itemprop="datePublished">
        Nov 20, 2020
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>I came across a HackerRank problem that seemed quite mathematically involved, though it was labeled a medium. The title of the problem is <a href="https://www.hackerrank.com/challenges/costly-graphs/problem">Costly Graphs</a>.</p>

<!--more-->

<h1 id="the-problem">The problem</h1>
<p>Let $G$ be a simple undirected graph. Given a number $K&gt;0$, the cost of the graph $C^K(G)$ is the quantity ++ C^K(G) = \sum_{v \in G} d(v)^K, ++ where $d(v)$ is the degree of vertex $v$. The question is as follows. Suppose $(N_1,K_1),\ldots, (N_T, K_T)$ are $T$ pairs of positive integers. For each pair, calculate ++ \sum_{|G| = N} C^K(G) \pmod{1005060097}. ++ We do not collapse isomorphic graphs.</p>

<p>The constraints are ++ \begin{align}1 \leq T &amp;\leq 2 \cdot 10^5,\\ \quad 1 \leq N &amp;\leq 10^9, \\ \quad 1 \leq K &amp;\leq 2\cdot 10^5,  \\ \quad \sum_{i=1}^T K_i &amp;\leq 2 \cdot 10^5. \end{align} ++</p>

<h2 id="example">Example</h2>
<p>For example, for $N=3$ and $K=2$, there are 8 possible graphs since there are 3 pairs of vertices and each of them can either have an edge or not. There is one with no edges, which doesn’t contribute to the cost. There are three with one edge, which contribute $3(1^2+1^2)=6$. There are three with two edges, which contribute $3(2^2+1^2+1^2)=18$. There is one with three edges, which contributes $2^2+2^2+2^2 = 12$. So for the pair $(N,K)=(3,2)$, we’d return ++(6+18+12) \pmod{1005060097}=36.++</p>

<h1 id="solution">Solution</h1>

<h2 id="setup">Setup</h2>

<p>Note that what we are trying to compute is a double sum. And what do we do if we have a double sum? Switch the sums. Below we label the vertices $1,2,\ldots,N$. 
++ \begin{align} C_N^K &amp;:= \sum_{|G|=N} \sum_{v \in G} d(v)^k \\
    &amp;= \sum_{v=1}^N \sum_{G \ni v, ~ |G|=N} d(v)^k \\
    &amp;= N \sum_{|G|=N} d(1)^k \quad \text{(by symmetry)} \\
    &amp;= N \sum_{i=0}^{N-1} |\{G ~|~ d(1) = i\}| ~ i^k. \end{align} ++</p>

<p>To find the coefficient of $i^k$, we just need to count the number of graphs which have $i$ edges coming out of vertex $1$. There are $N-1$ potential edges emanating from node $1$, and $i$ of them must be edges and $N-1-i$ of them must be empty. There are ${N-1 \choose i}$ ways to choose these nonempty edges. Then the rest of the $N-1$ nodes can be whatever graph they want. So this contributes a factor of $2^{N-1 \choose 2}$. Therefore 
++ |\{ G | d(1) = i\}| = {N-1 \choose i} 2^{(N-1)(N-2)/2}. ++</p>

<p>Our final formula is ++ \boxed{C_N^K = N 2^{(N-1)(N-2)/2} \sum_{i=0}^{N-1} {N-1 \choose i} i^k.} ++</p>

<p>I wrote this code (knowing it wasn’t quite fast enough yet, since $N$ can go up to $10^9$) to check if my formla is correct. Turns out it is, but of course it times out since it’s $O(NT)$.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import math

prime = 1005060097

def choose(n,k):
    return math.factorial(n) // math.factorial(n-k) // math.factorial(k)

def cost(n,k):
    if n &lt;= 1:
        return 0
    coef = n * pow(2, (n-1) * (n-2) // 2, prime)
    return (coef * sum(choose(n-1, i) * pow(i,k,prime) for i in range(n))) % prime

T = int(input())

for i in range(T):
    n,k = [int(i) for i in input().split()]
    print(cost(n,k))
</code></pre></div></div>

<p>But I do like the simplicity. Now we must make it more complicated to make it faster. There is definitely a complicated formula for that sum. I empirically verified the following identities using OEIS:
++ \begin{align} \sum_{i=0}^{m} {m \choose i} i^2 &amp;= m(m+1)2^{m-2}, \\ \sum_{i=0}^m {m\choose i} i^3 &amp;= m^2(m+3) 2^{m-3}, \\ \sum_{i=0}^m {m \choose i} i^4 &amp;= m(m+1)(m^2+5m-2) 2^{m-4}. \end{align} ++</p>

<p>Let’s look toward a closed form solution for $C_N^K$. Let ++S_m^k := \sum_{i=0}^m {m \choose i} i^k. ++
Using the recurrence relation for ${m\choose i}$, we get
++ 
\begin{align}
    S_m^k &amp;=\sum_{i=0}^m {m \choose i} i^k \\
    &amp;= \sum_{i=0}^m \left( {m-1 \choose i} + {m-1 \choose i-1} \right) i^k \\
    &amp;= S_{m-1}^k + \sum_{i=0}^{m-1} {m-1 \choose i} (i+1)^k \\
    &amp;= S_{m-1}^k + \sum_{i=0}^{m-1} {m-1 \choose i} \sum_{\ell=0}^k {k \choose \ell} i^\ell \\
    &amp;= S_{m-1}^k + \sum_{\ell=0}^k {k \choose \ell} \sum_{i=0}^{m-1} {m-1 \choose i} i^\ell \\
    &amp;=\boxed{ S_{m-1}^k + \sum_{\ell=0}^k {k \choose \ell} S_{m-1}^\ell.}
\end{align}
++
Whew, ok. I tried for a long time to find a closed form for this recurrence relation, and it’s doable for fixed $k$. But I can’t get a formula given $m$ and $k$. This is a problem because right now, my algorithm is $O(NT)$ which is too large. But there is a painful way to compute the closed form for the recurrence relation by incrementing $k$. That would make my algorithm $O(K+T)$ (sorry I’ve been switching $k$ and $K$) by precomputing the formulas then running the test cases, which would be way better.</p>

<h2 id="switching-formulas-proof">Switching Formulas: Proof</h2>

<p>To find the closed form with the above recurrence relation, I think I’d need to solve a $k$-dimensional linear system incrementally, which seems too complicated if there is no obvious pattern (which there is not). Instead, we switch to another recurrence.</p>

<p>Consider $f_m(x) = (1+x)^m$. Then let $(Tf_m)(x) = x f’(x)$. The claim is that ++ (T^kf_m)(1) = S_m^k. ++ Here is the proof. If $p(x)$ is a polynomial in $x$, then
++\begin{align}
    p(x) &amp;= a_0 + a_1x + a_2x^2 + a_3x^3 + \cdots \\
    Tp(x) &amp;= a_1x + 2a_2x^2 + 3a_3x^3 + \cdots \\
    T^2p(x) &amp;= a_1x + 2^2 a_2x^2 + 3^2a_3x^3 + \cdots \\
    T^kp(x) &amp;= a_1x + 2^k a_2x^2 + 3^k a_3x^3 + \cdots.
\end{align}++</p>

<p>Start with $T^0f_m(x) = (1+x)^m = \sum_{i=0}^m {m \choose i} x^i$. We simply compute
++ T^kf_m(x) = \sum_{i=0}^m {m\choose i} i^k x^i. ++ Plugging in $x=1$ completes the proof.</p>

<h2 id="computing-alternate-formula">Computing Alternate Formula</h2>

<p>Now we work with this $T^kf_m(x)$ formula.</p>

<p>To compute $(T^kf_m)(1)$ on the computer, we need to discover a little more structure in $T^kf_m(x)$. We claim that $T^kf_m(x)$ is of the form ++ \boxed{T^kf_m(x) = p_k(x,m) (1+x)^{m-k}} \quad \text{ for } 0\leq k \leq m ++ where $p_k(x,m)$ is a bivariate polynomial of degree $k$ in both $x$ and $m$ (e.g. $p_2(x,m) = mx(mx+1)$). Certainly this is true for $k=0$. If it’s true for $k=1$, then 
++ \begin{align}
    T^kf_m(x) &amp;= T(T^{k-1}f_m)(x) \\
    &amp;= T(p_{k-1}(x,m) (1+x)^{m-k+1}) \\
    &amp;= x\left(p_{k-1}’(x,m) (1+x)^{m-k+1} + p_{k-1}(x,m) (m-k+1)(1+x)^{m-k}\right) \\
    &amp;= x((1+x)\cdot p_{k-1}’(x,m) + (m-k+1)\cdot p_{k-1}(x,m)) (1+x)^{m-k}\\
    &amp;=: p_k(x,m) (1+x)^{m-k}.
\end{align} ++
The coefficient of $(1+x)^{m-k}$ above is $p_k(x,m)$, and we see that it has degree $k$ in both $x$ and $m$.</p>

<p>As we see above, the expression $p_k(x,m)$ follows the rule ++ \boxed{p_k(x,m) = x(1+x)\cdot p_{k-1}’(x,m) + x(m-k+1)\cdot p_{k-1}(x,m), \quad p_0(x,m) = 1.} ++</p>

<p>Also a note that for $k&gt; m$ we see that $T^kf_m(x) = T^{k-m} p_m(x,m)$. But this computation should be easier than the case $k\leq m$. It is simply a repeated shift and multiplication.</p>

<p>We must now think about how to store the formula once we get it. For each $k$, we will have a hash table to store the coefficient of $x^im^j$. Theoretically this could take $O(k^2)$ space and time, but in practice it seems to be okay.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>formula_cache = []

def grad(formula):
    ''' computes the gradient of a polynomial given its formula. '''
    gradient = {}
    for (i,j) in formula:
        if i &gt; 0:
            gradient[(i-1,j)] = gradient.get((i-1,j), 0) + i * formula[(i,j)]
    return gradient

def build_cache(k):
    ''' computes p_k(x,m) up to k. '''

    for ell in range(k+1):
        if ell == 0: 
            formula_cache.append({(0,0): 1})
        else:
            prev_formula = formula_cache[ell-1]
            curr_formula = {}
            grad_prev = grad(prev_formula)

            for (i,j) in prev_formula:
                term = prev_formula[(i,j)]
                curr_formula[(i+1,j+1)] = curr_formula.get((i+1,j+1), 0) + term
                curr_formula[(i+1,j)]   = curr_formula.get((i+1,j), 0)   + (-ell + 1) * term
            
            for (i,j) in grad_prev:
                term = grad_prev[(i,j)]
                curr_formula[(i+2,j)] = curr_formula.get((i+2,j), 0) + term
                curr_formula[(i+1,j)] = curr_formula.get((i+1,j), 0) + term

            formula_cache.append(curr_formula)
</code></pre></div></div>

<p>Now for each test case, we simply look up the largest $K$, build our cache up to that $K$, then compute. The final code looks like this.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>


  </div><a class="u-url" href="/2020/11/20/costly-graphs.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Hong Suh</li>
          <li><a class="u-email" href="mailto:hong.suh7@gmail.com">hong.suh7@gmail.com</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>A collection of math topics with lots of pictures and animations!
</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>
